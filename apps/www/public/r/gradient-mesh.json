{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "gradient-mesh",
  "type": "registry:component",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "registry/default/components/gradient-mesh.tsx",
      "content": "\"use client\";\nimport { Renderer, Program, Mesh, Color, Triangle } from \"ogl\";\nimport React, { useEffect, useRef } from \"react\";\n\n// Vertex shader\nconst vert = `\nattribute vec2 uv;\nattribute vec2 position;\n\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4(position, 0, 1);\n}\n`;\n\n// Fragment shader with water effect\nconst frag = (distortion: number) => `\nprecision highp float;\n\nuniform float uTime;\nuniform float uSwirl;\nuniform float uSpeed;\nuniform float uScale;\nuniform float uOffsetX;\nuniform float uOffsetY;\nuniform float uRotation;\nuniform float uWaveAmp;\nuniform float uWaveFreq;\nuniform float uWaveSpeed;\nuniform float uGrain;\nuniform vec3 uColorA;\nuniform vec3 uColorB;\nuniform vec3 uColorC;\nuniform vec3 uResolution;\n\nvarying vec2 vUv;\n\n// 2D noise-like wave\nfloat wave(vec2 uv, float freq, float speed, float time) {\n    return sin(uv.x * freq + time * speed) * cos(uv.y * freq + time * speed);\n}\n\n// Simple random noise\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// Color Dodge blending\nvec3 colorDodge(vec3 base, vec3 blend) {\n    return min(base / (1.0 - blend + 0.0001), 1.0);\n}\n\nvoid main() {\n    float mr = min(uResolution.x, uResolution.y);\n    vec2 uv = (vUv.xy * 2.0 - 1.0) * uResolution.xy / mr;\n\n    // Scale and offset\n    uv = uv * uScale + vec2(uOffsetX, uOffsetY);\n\n    // Rotation\n    float cosR = cos(uRotation);\n    float sinR = sin(uRotation);\n    uv = vec2(\n        uv.x * cosR - uv.y * sinR,\n        uv.x * sinR + uv.y * cosR\n    );\n\n    // Water waves\n    uv.x += wave(uv, uWaveFreq, uWaveSpeed, uTime) * uWaveAmp;\n    uv.y += wave(uv + 10.0, uWaveFreq * 1.5, uWaveSpeed * 0.8, uTime) * uWaveAmp * 0.5;\n\n    // Swirl\n    float angle = atan(uv.y, uv.x);\n    float radius = length(uv);\n    angle += uSwirl * radius;\n    uv = vec2(cos(angle), sin(angle)) * radius;\n\n    // Distortion loop\n    float d = -uTime * 0.5 * uSpeed;\n    float a = 0.0;\n    for (float i = 0.0; i < ${distortion.toFixed(1)}; ++i) {\n        a += cos(i - d - a * uv.x);\n        d += sin(uv.y * i + a);\n    }\n    d += uTime * 0.5 * uSpeed;\n\n    // Base color mixing\n    float mix1 = (sin(d) + 1.0) * 0.5;\n    float mix2 = (cos(a) + 1.0) * 0.5;\n    vec3 col = mix(uColorA, uColorB, mix1);\n    col = mix(col, uColorC, mix2);\n\n    // Grain using Color Dodge\n    float grain = (random(gl_FragCoord.xy + uTime) - 0.5) * uGrain;\n    vec3 grainCol = vec3(0.5 + grain); // grayish grain\n    col = colorDodge(col, grainCol);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n`;\n\n\n\ninterface NovatrixProps {\n  colors?: string[];\n  distortion?: number;\n  swirl?: number;\n  speed?: number;\n  scale?: number;\n  offsetX?: number;\n  offsetY?: number;\n  rotation?: number; \n  waveAmp?: number;\n  waveFreq?: number;\n  waveSpeed?: number;\n  grain?: number; // NEW\n}\n\n// Convert hex to normalized RGB\nconst hexToRgb = (hex: string): [number, number, number] => {\n  const cleanHex = hex.replace(\"#\", \"\");\n  const r = parseInt(cleanHex.substring(0, 2), 16) / 255;\n  const g = parseInt(cleanHex.substring(2, 4), 16) / 255;\n  const b = parseInt(cleanHex.substring(4, 6), 16) / 255;\n  return [r, g, b];\n};\n\nexport function GradientMesh(props: NovatrixProps) {\n  const ctnDom = useRef<HTMLDivElement>(null);\n  const {\n  colors = [\"#3b2a8d\", \"#aaa7d7\", \"#f75092\"],\n  distortion = 5,\n  swirl = 0.5,\n  speed = 1.0,\n  scale = 1,\n  offsetX = 0.0,\n  offsetY = 0.0,\n  rotation = 90,\n  waveAmp = 0.1,\n  waveFreq = 10.0,\n  waveSpeed = 0.2,\n  grain = 0.06,  \n  ...rest\n} = props;\n\n  useEffect(() => {\n    if (!ctnDom.current) return;\n\n    const ctn = ctnDom.current;\n    const renderer = new Renderer();\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 1);\n\n    function resize() {\n      renderer.setSize(ctn.offsetWidth, ctn.offsetHeight);\n    }\n    window.addEventListener(\"resize\", resize, false);\n    resize();\n\n    const geometry = new Triangle(gl);\n\n    const rgbColors = colors.slice(0, 3).map(hexToRgb);\n    const uniforms: any = {\n      uTime: { value: 0 },\n      uSwirl: { value: swirl },\n      uSpeed: { value: speed },\n      uScale: { value: scale },\n      uOffsetX: { value: offsetX },\n      uOffsetY: { value: offsetY },\n      uRotation: { value: rotation },\n      uWaveAmp: { value: waveAmp },\n      uWaveFreq: { value: waveFreq },\n      uWaveSpeed: { value: waveSpeed },\n      uResolution: {\n        value: new Color(\n          gl.canvas.width,\n          gl.canvas.height,\n          gl.canvas.width / gl.canvas.height\n        ),\n      },\n      uGrain: { value: grain },\n\n    };\n\n    const labels = [\"A\", \"B\", \"C\"];\n    rgbColors.forEach((c, i) => {\n      uniforms[`uColor${labels[i]}`] = { value: new Color(...c) };\n    });\n\n    const program = new Program(gl, {\n      vertex: vert,\n      fragment: frag(distortion),\n      uniforms,\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n\n    let animateId: number;\n    function update(t: number) {\n      animateId = requestAnimationFrame(update);\n      program.uniforms.uTime.value = t * 0.001;\n      renderer.render({ scene: mesh });\n    }\n    animateId = requestAnimationFrame(update);\n\n    ctn.appendChild(gl.canvas);\n\n    return () => {\n      cancelAnimationFrame(animateId);\n      window.removeEventListener(\"resize\", resize);\n      ctn.removeChild(gl.canvas);\n      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    };\n  }, [\n    colors, distortion, swirl, speed, scale,\n    offsetX, offsetY, rotation, waveAmp, waveFreq, waveSpeed\n  ]);\n\n  return (\n    <div\n      ref={ctnDom}\n      style={{ width: \"100%\", height: \"100%\", position: \"absolute\", overflow: \"hidden\"  }}\n      {...rest}\n    />\n  );\n}\n ",
      "type": "registry:component"
    }
  ]
}