{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "shader-ripple",
  "type": "registry:component",
  "dependencies": [
    "three"
  ],
  "files": [
    {
      "path": "registry/default/components/shader-ripple.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n//@ts-nocheck\n\"use client\";\n\nimport { useEffect, useRef } from \"react\";\nimport * as THREE from \"three\";\n\ninterface ShaderRippleProps {\n  speed?: number;\n  lineWidth?: number;\n  rippleCount?: number;\n  colorLayers?: number;\n  backgroundColor?: string;\n  rotation?: number;\n  timeScale?: number;\n  opacity?: number;\n  waveIntensity?: number;\n  animationSpeed?: number;\n  loopDuration?: number;\n  scale?: number;\n  color1?: string;\n  color2?: string;\n  color3?: string;\n  mod?: number;\n  className?: string;\n}\n\nexport function ShaderRipple({\n  speed = 0.05,\n  lineWidth = 0.002,\n  rippleCount = 8,\n  colorLayers = 3,\n  backgroundColor = \"transparent\",\n  rotation = 135,\n  timeScale = 0.5,\n  opacity = 1.0,\n  waveIntensity = 0,\n  animationSpeed = 1.0,\n  loopDuration = 0.7,\n  scale = 1,\n  color1 = \"#FF00FF\",\n  color2 = \"#FF00FF\",\n  color3 = \"#FF6EC7\",\n  mod = 0.2,\n  className = \"\",\n}: ShaderRippleProps) {\n  // Convert degrees to radians\n  const rotationRadians = (rotation * Math.PI) / 180;\n\n  const containerRef = useRef<HTMLDivElement>(null);\n  const sceneRef = useRef<{\n    camera: THREE.Camera;\n    scene: THREE.Scene;\n    renderer: THREE.WebGLRenderer;\n    uniforms: any;\n    animationId: number;\n  } | null>(null);\n\n  // Convert hex color to vec3\n  const hexToVec3 = (hex: string) => {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result\n      ? new THREE.Vector3(\n          parseInt(result[1], 16) / 255,\n          parseInt(result[2], 16) / 255,\n          parseInt(result[3], 16) / 255\n        )\n      : new THREE.Vector3(1, 0, 0);\n  };\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const container = containerRef.current;\n\n    const vertexShader = `\n      void main() {\n        gl_Position = vec4( position, 1.0 );\n      }\n    `;\n\n    const fragmentShader = `\n      #define TWO_PI 6.2831853072\n      #define PI 3.14159265359\n\n      precision highp float;\n      uniform vec2 resolution;\n      uniform float time;\n      uniform float lineWidth;\n      uniform int rippleCount;\n      uniform int colorLayers;\n      uniform float rotation;\n      uniform float timeScale;\n      uniform float opacity;\n      uniform float waveIntensity;\n      uniform float scale;\n      uniform vec3 color1;\n      uniform vec3 color2;\n      uniform vec3 color3;\n      uniform float loopDuration;\n      uniform float modValue;\n\n      vec2 rotate(vec2 v, float a) {\n        float s = sin(a);\n        float c = cos(a);\n        mat2 m = mat2(c, -s, s, c);\n        return m * v;\n      }\n\n      // Smooth easing function (ease-in-out)\n      float easeInOutCubic(float t) {\n        return t < 0.5 ? 4.0 * t * t * t : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;\n      }\n\n      void main(void) {\n        vec2 uv = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n        \n        // Apply scale\n        uv = uv / scale;\n        \n        // Apply rotation\n        uv = rotate(uv, rotation);\n        \n        // Add wave distortion\n        uv.x += sin(uv.y * 5.0 + time * timeScale * 0.1) * waveIntensity;\n        uv.y += cos(uv.x * 5.0 + time * timeScale * 0.1) * waveIntensity;\n        \n        // Normalize time to loop duration\n        float t = mod(time * timeScale * 0.05, loopDuration);\n        \n        // Calculate smooth fade factor (0 to 1 to 0)\n        float fadeProgress = t / loopDuration;\n        float smoothFade = sin(fadeProgress * PI);\n        smoothFade = easeInOutCubic(smoothFade);\n\n        vec3 finalColor = vec3(0.0);\n        float totalIntensity = 0.0;\n        \n        for(int j = 0; j < 5; j++){\n          if(j >= colorLayers) break;\n          \n          vec3 layerColor;\n          if(j == 0) layerColor = color1;\n          else if(j == 1) layerColor = color2;\n          else layerColor = color3;\n          \n          float intensity = 0.0;\n          for(int i = 0; i < 20; i++){\n            if(i >= rippleCount) break;\n            float rippleTime = fract(t + float(i)*0.01 - 0.01*float(j));\n            // Start from 0 size and expand outward with easing\n            float rippleRadius = rippleTime * rippleTime * 8.0;\n            intensity += lineWidth*float(i*i) / abs(rippleRadius - length(uv) + mod(uv.x+uv.y, modValue));\n          }\n          \n          finalColor += layerColor * intensity;\n          totalIntensity += intensity;\n        }\n        \n        // Normalize to prevent overly bright areas\n        if(totalIntensity > 0.0) {\n          finalColor = finalColor / max(totalIntensity * 0.3, 1.0);\n        }\n        \n        // Calculate alpha based on intensity for transparency\n        float alpha = min(totalIntensity * 0.2, 1.0) * opacity * smoothFade;\n        \n        gl_FragColor = vec4(finalColor * smoothFade, alpha);\n      }\n    `;\n\n    const camera = new THREE.Camera();\n    camera.position.z = 1;\n\n    const scene = new THREE.Scene();\n    const geometry = new THREE.PlaneGeometry(2, 2);\n\n    const uniforms = {\n      time: { type: \"f\", value: 1.0 },\n      resolution: { type: \"v2\", value: new THREE.Vector2() },\n      lineWidth: { type: \"f\", value: lineWidth },\n      rippleCount: { type: \"i\", value: rippleCount },\n      colorLayers: { type: \"i\", value: colorLayers },\n      rotation: { type: \"f\", value: rotationRadians },\n      timeScale: { type: \"f\", value: timeScale },\n      opacity: { type: \"f\", value: opacity },\n      waveIntensity: { type: \"f\", value: waveIntensity },\n      scale: { type: \"f\", value: scale },\n      color1: { type: \"v3\", value: hexToVec3(color1) },\n      color2: { type: \"v3\", value: hexToVec3(color2) },\n      color3: { type: \"v3\", value: hexToVec3(color3) },\n      loopDuration: { type: \"f\", value: loopDuration },\n      modValue: { type: \"f\", value: mod },\n    };\n\n    const material = new THREE.ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      transparent: true,\n      blending: THREE.AdditiveBlending,\n      depthWrite: false,\n    });\n\n    const mesh = new THREE.Mesh(geometry, material);\n    scene.add(mesh);\n\n    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setClearColor(0x000000, 0);\n\n    container.appendChild(renderer.domElement);\n\n    const onWindowResize = () => {\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n      renderer.setSize(width, height);\n      uniforms.resolution.value.x = renderer.domElement.width;\n      uniforms.resolution.value.y = renderer.domElement.height;\n    };\n\n    onWindowResize();\n    window.addEventListener(\"resize\", onWindowResize, false);\n\n    const animate = () => {\n      const animationId = requestAnimationFrame(animate);\n      uniforms.time.value += speed * animationSpeed;\n      renderer.render(scene, camera);\n\n      if (sceneRef.current) {\n        sceneRef.current.animationId = animationId;\n      }\n    };\n\n    sceneRef.current = {\n      camera,\n      scene,\n      renderer,\n      uniforms,\n      animationId: 0,\n    };\n\n    animate();\n\n    return () => {\n      window.removeEventListener(\"resize\", onWindowResize);\n\n      if (sceneRef.current) {\n        cancelAnimationFrame(sceneRef.current.animationId);\n\n        if (container && sceneRef.current.renderer.domElement) {\n          container.removeChild(sceneRef.current.renderer.domElement);\n        }\n\n        sceneRef.current.renderer.dispose();\n        geometry.dispose();\n        material.dispose();\n      }\n    };\n  }, [\n    speed,\n    lineWidth,\n    rippleCount,\n    colorLayers,\n    rotation,\n    timeScale,\n    opacity,\n    waveIntensity,\n    animationSpeed,\n    loopDuration,\n    scale,\n    color1,\n    color2,\n    color3,\n    mod,\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`h-full w-full ${className}`}\n      style={{\n        background: backgroundColor,\n        overflow: \"hidden\",\n      }}\n    />\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}