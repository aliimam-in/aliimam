{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "fireball",
  "type": "registry:component",
  "files": [
    {
      "path": "registry/default/components/fireball.tsx",
      "content": "//@ts-nocheck\n\"use client\"\n\nimport type React from \"react\"\nimport { useEffect, useRef, useId } from \"react\"\n\ntype GooeyTrailProps = {\n  // Visual\n  colors?: string[] // particle colors\n  background?: string // wrapper background color, e.g. \"#191747\" or \"transparent\"\n  blur?: number // stdDeviation for the goo filter\n  blobRadius?: number // radius of the main following blob\n  particleRadiusRange?: [number, number] // min/max particle radius\n  useXorComposite?: boolean // use \"xor\" composite operation for extra goo effect\n  ballColor?: string \n  // Behavior\n  particleCount?: number // how many particles\n  followStrength?: number // 0..1, how fast the blob follows the pointer\n  fullScreen?: boolean // if true, component fills viewport; else fills parent container\n  className?: string\n  style?: React.CSSProperties\n}\n\ntype Particle = {\n  x: number\n  y: number\n  r: number\n  color: string\n  vx: number\n  vy: number\n  life: number\n}\n\nexport function FireBall({\n  // Visual defaults adapted from provided snippets\n  colors = [\"#ff0000\", \"#0000ff\", \"#00ff00\"],\n  background = \"transparent\",\n  blur = 4,\n  blobRadius = 8,\n  ballColor = \"blue\",\n  particleRadiusRange = [2, 4],\n  useXorComposite = true, \n  particleCount = 50,\n  followStrength = 0.2,\n  fullScreen = false,\n  className,\n  style,\n}: GooeyTrailProps) {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null)\n  const frameRef = useRef<number | null>(null)\n  const particlesRef = useRef<Particle[]>([])\n  const accelRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 })\n  const posRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 })\n  const sizeRef = useRef<{ width: number; height: number }>({ width: 0, height: 0 })\n\n  // Unique filter ID per instance to avoid collisions\n  const filterId = useId().replace(/:/g, \"-\")\n  const filterUrl = `url(#goo-${filterId})`\n\n  // Helpers\n  const randInt = (min: number, max: number) => Math.round(Math.random() * (max - min) + min)\n\n  const resetParticle = (p: Particle) => {\n    const [minR, maxR] = particleRadiusRange\n    p.x = posRef.current.x\n    p.y = posRef.current.y\n    p.r = randInt(minR, maxR)\n    p.color = colors[Math.floor(Math.random() * colors.length)]\n    p.vx = randInt(-2, 2)\n    p.vy = randInt(5, 10)\n    p.life = randInt(20, 30)\n  }\n\n  // Resize canvas for DPR and container size\n  const resizeCanvas = () => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n    const dpr = Math.max(1, window.devicePixelRatio || 1)\n    const parent = canvas.parentElement\n    const rect = fullScreen\n      ? { width: window.innerWidth, height: window.innerHeight }\n      : parent\n        ? parent.getBoundingClientRect()\n        : { width: 800, height: 600 }\n\n    sizeRef.current = { width: rect.width, height: rect.height }\n    canvas.style.width = `${rect.width}px`\n    canvas.style.height = `${rect.height}px`\n    canvas.width = Math.floor(rect.width * dpr)\n    canvas.height = Math.floor(rect.height * dpr)\n\n    const ctx = canvas.getContext(\"2d\")\n    if (!ctx) return\n    ctx.setTransform(1, 0, 0, 1, 0, 0)\n    ctx.scale(dpr, dpr)\n  }\n\n  useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n    const ctx = canvas.getContext(\"2d\")\n    if (!ctx) return\n\n    // Initialize sizes\n    resizeCanvas()\n\n    // Start positions at center\n    posRef.current = { x: sizeRef.current.width / 2, y: sizeRef.current.height / 2 }\n    accelRef.current = { ...posRef.current }\n\n    // Initialize particles\n    particlesRef.current = Array.from({ length: particleCount }, (): Particle => {\n      const p: Particle = {\n        x: posRef.current.x,\n        y: posRef.current.y,\n        r: randInt(particleRadiusRange[0], particleRadiusRange[1]),\n        color: colors[Math.floor(Math.random() * colors.length)],\n        vx: randInt(-2, 2),\n        vy: randInt(5, 10),\n        life: randInt(20, 30),\n      }\n      return p\n    })\n\n    function onPointerMove(e: PointerEvent) {\n      const rect = canvas.getBoundingClientRect()\n      // If fullScreen, clientX/Y are fine; otherwise adjust to canvas local coords\n      const x = fullScreen ? e.clientX : e.clientX - rect.left\n      const y = fullScreen ? e.clientY : e.clientY - rect.top\n      posRef.current.x = x\n      posRef.current.y = y\n    }\n\n    function onResize() {\n      resizeCanvas()\n    }\n\n    window.addEventListener(\"pointermove\", onPointerMove, { passive: true })\n    window.addEventListener(\"resize\", onResize)\n\n    const render = () => {\n      const { width, height } = sizeRef.current\n      // Clear in CSS pixel units (since we scaled by DPR)\n      ctx.clearRect(0, 0, width, height)\n\n      // Smoothly follow pointer\n      accelRef.current.x += (posRef.current.x - accelRef.current.x) * followStrength\n      accelRef.current.y += (posRef.current.y - accelRef.current.y) * followStrength\n\n      // Draw main blob\n      ctx.save()\n      if (useXorComposite) ctx.globalCompositeOperation = \"source-over\"\n      ctx.beginPath()\n      ctx.fillStyle = ballColor\n      ctx.arc(accelRef.current.x, accelRef.current.y, blobRadius, 0, Math.PI * 2)\n      ctx.fill()\n\n      // Toggle XOR for gooey overlap if desired\n      if (useXorComposite) ctx.globalCompositeOperation = \"xor\"\n\n      // Draw particles\n      const arr = particlesRef.current\n      for (let i = 0; i < arr.length; i++) {\n        const p = arr[i]\n        ctx.beginPath()\n        ctx.fillStyle = p.color\n        ctx.arc(p.x, p.y, Math.max(0, p.r), 0, Math.PI * 2)\n        ctx.fill()\n\n        p.x += p.vx\n        p.y -= p.vy\n        p.r -= 0.075\n        p.life--\n\n        if (p.life < 0 || p.r < 0) {\n          resetParticle(p)\n        }\n      }\n      ctx.restore()\n\n      frameRef.current = requestAnimationFrame(render)\n    }\n\n    frameRef.current = requestAnimationFrame(render)\n\n    return () => {\n      if (frameRef.current) cancelAnimationFrame(frameRef.current)\n      window.removeEventListener(\"pointermove\", onPointerMove)\n      window.removeEventListener(\"resize\", onResize)\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [particleCount, colors, particleRadiusRange, blobRadius, followStrength, fullScreen, useXorComposite])\n\n  return (\n    <div\n      className={className}\n      style={{\n        position: fullScreen ? \"fixed\" : \"absolute\",\n        inset: fullScreen ? 0 : undefined,\n        width: fullScreen ? \"100vw\" : \"100%\",\n        height: fullScreen ? \"100vh\" : \"100%\",\n        overflow: \"hidden\",\n        background,\n        ...style,\n      }}\n    >\n      <svg aria-hidden=\"true\" width=\"0\" height=\"0\" style={{ position: \"absolute\" }} focusable=\"false\">\n        <filter id={`goo-${filterId}`}>\n          <feGaussianBlur in=\"SourceGraphic\" stdDeviation={blur} result=\"blur\" />\n          <feColorMatrix in=\"blur\" mode=\"matrix\" values=\"1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 60 -9\" />\n        </filter>\n      </svg>\n\n      <canvas\n        ref={canvasRef}\n        style={{\n          width: \"100%\",\n          height: \"100%\",\n          display: \"block\",\n          // Ensure the SVG filter applies to the canvas\n          filter: filterUrl as any,\n          WebkitFilter: filterUrl as any,\n          pointerEvents: \"none\",\n        }}\n        aria-hidden=\"true\"\n      />\n    </div>\n  )\n}\n",
      "type": "registry:component"
    }
  ]
}