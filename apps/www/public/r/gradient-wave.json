{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "gradient-wave",
  "type": "registry:component",
  "files": [
    {
      "path": "registry/default/components/gradient-wave.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\"use client\";\n\nimport { useEffect, useRef } from \"react\";\n\n// TypeScript types for the Gradient system\ntype UniformType =\n  | \"float\"\n  | \"int\"\n  | \"vec2\"\n  | \"vec3\"\n  | \"vec4\"\n  | \"mat4\"\n  | \"array\"\n  | \"struct\";\n\n// Utility functions\nfunction normalizeColor(hexCode: number): number[] {\n  return [\n    ((hexCode >> 16) & 255) / 255,\n    ((hexCode >> 8) & 255) / 255,\n    (255 & hexCode) / 255,\n  ];\n}\n\n// MiniGL WebGL wrapper class\nclass MiniGl {\n  canvas!: HTMLCanvasElement;\n  gl!: WebGLRenderingContext;\n  meshes!: any[];\n  commonUniforms: any;\n  width?: number;\n  height?: number;\n  debug!: (...args: any[]) => void;\n  lastDebugMsg?: Date;\n  Material: any;\n  Uniform: any;\n  PlaneGeometry: any;\n  Mesh: any;\n  Attribute: any;\n\n  constructor(\n    canvas: HTMLCanvasElement,\n    width?: number | null,\n    height?: number | null,\n    debug = false\n  ) {\n    const _miniGl = this;\n    const debug_output =\n      document.location.search.toLowerCase().indexOf(\"debug=webgl\") !== -1;\n\n    _miniGl.canvas = canvas;\n    _miniGl.gl = _miniGl.canvas.getContext(\"webgl\", { antialias: true })!;\n    _miniGl.meshes = [];\n\n    const context = _miniGl.gl;\n\n    if (width && height) this.setSize(width, height);\n\n    _miniGl.debug =\n      debug && debug_output\n        ? function (e: string, ...args: any[]) {\n            const t = new Date();\n            if (\n              !_miniGl.lastDebugMsg ||\n              t.getTime() - _miniGl.lastDebugMsg.getTime() > 1000\n            ) {\n              console.log(\"---\");\n            }\n            console.log(\n              t.toLocaleTimeString() +\n                Array(Math.max(0, 32 - e.length)).join(\" \") +\n                e +\n                \": \",\n              ...args\n            );\n            _miniGl.lastDebugMsg = t;\n          }\n        : () => {};\n\n    // Define Material class\n    _miniGl.Material = class {\n      uniforms: any;\n      uniformInstances!: any[];\n      vertexSource!: string;\n      Source!: string;\n      vertexShader!: WebGLShader;\n      fragmentShader!: WebGLShader;\n      program!: WebGLProgram;\n\n      constructor(\n        vertexShaders: string,\n        fragments: string,\n        uniforms: any = {}\n      ) {\n        const material = this;\n\n        function getShaderByType(type: number, source: string): WebGLShader {\n          const shader = context.createShader(type)!;\n          context.shaderSource(shader, source);\n          context.compileShader(shader);\n          if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {\n            const errorLog = context.getShaderInfoLog(shader);\n            console.log(\"VERTEX SHADER SOURCE:\\n\", source); \n            throw new Error(errorLog || \"Unknown shader compilation error\");\n          }\n\n          _miniGl.debug(\"Material.compileShaderSource\", { source });\n          return shader;\n        }\n\n        function getUniformVariableDeclarations(\n          uniforms: any,\n          type: string\n        ): string {\n          return Object.entries(uniforms)\n            .map(([uniform, value]: [string, any]) =>\n              value.getDeclaration(uniform, type)\n            )\n            .join(\"\\n\");\n        }\n\n        material.uniforms = uniforms;\n        material.uniformInstances = [];\n\n        const prefix = \"\\n              precision highp float;\\n            \";\n\n        material.vertexSource = `\n              ${prefix}\n              attribute vec4 position;\n              attribute vec2 uv;\n              attribute vec2 uvNorm;\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"vertex\")}\n              ${getUniformVariableDeclarations(uniforms, \"vertex\")}\n              ${vertexShaders}\n            `;\n\n        material.Source = `\n              ${prefix}\n              ${getUniformVariableDeclarations(_miniGl.commonUniforms, \"fragment\")}\n              ${getUniformVariableDeclarations(uniforms, \"fragment\")}\n              ${fragments}\n            `;\n\n        material.vertexShader = getShaderByType(\n          context.VERTEX_SHADER,\n          material.vertexSource\n        );\n        material.fragmentShader = getShaderByType(\n          context.FRAGMENT_SHADER,\n          material.Source\n        );\n        material.program = context.createProgram()!;\n\n        context.attachShader(material.program, material.vertexShader);\n        context.attachShader(material.program, material.fragmentShader);\n        context.linkProgram(material.program);\n\n        if (\n          !context.getProgramParameter(material.program, context.LINK_STATUS)\n        ) {\n          console.error(context.getProgramInfoLog(material.program));\n        }\n\n        context.useProgram(material.program);\n        material.attachUniforms(undefined, _miniGl.commonUniforms);\n        material.attachUniforms(undefined, material.uniforms);\n      }\n\n      attachUniforms(name: string | undefined, uniforms: any): void {\n        const material = this;\n        if (name === undefined) {\n          Object.entries(uniforms).forEach(([name, uniform]) => {\n            material.attachUniforms(name, uniform);\n          });\n        } else if (uniforms.type === \"array\") {\n          uniforms.value.forEach((uniform: any, i: number) =>\n            material.attachUniforms(`${name}[${i}]`, uniform)\n          );\n        } else if (uniforms.type === \"struct\") {\n          Object.entries(uniforms.value).forEach(([uniform, i]) =>\n            material.attachUniforms(`${name}.${uniform}`, i)\n          );\n        } else {\n          _miniGl.debug(\"Material.attachUniforms\", { name, uniform: uniforms });\n          material.uniformInstances.push({\n            uniform: uniforms,\n            location: context.getUniformLocation(material.program, name),\n          });\n        }\n      }\n    };\n\n    // Define Uniform class\n    _miniGl.Uniform = class {\n      type: UniformType;\n      value: any;\n      typeFn: string;\n      excludeFrom?: string;\n      transpose?: boolean;\n\n      constructor(e: any) {\n        this.type = \"float\";\n        Object.assign(this, e);\n        this.typeFn =\n          {\n            float: \"1f\",\n            int: \"1i\",\n            vec2: \"2fv\",\n            vec3: \"3fv\",\n            vec4: \"4fv\",\n            mat4: \"Matrix4fv\",\n          }[this.type as string] || \"1f\";\n        this.update();\n      }\n\n      update(value?: any): void {\n        if (this.value !== undefined) {\n          (context as any)[`uniform${this.typeFn}`](\n            value,\n            this.typeFn.indexOf(\"Matrix\") === 0 ? this.transpose : this.value,\n            this.typeFn.indexOf(\"Matrix\") === 0 ? this.value : null\n          );\n        }\n      }\n\n      getDeclaration(name: string, type: string, length?: number): string {\n        const uniform = this;\n        if (uniform.excludeFrom !== type) {\n          if (uniform.type === \"array\") {\n            return (\n              uniform.value[0].getDeclaration(\n                name,\n                type,\n                uniform.value.length\n              ) + `\\nconst int ${name}_length = ${uniform.value.length};`\n            );\n          }\n          if (uniform.type === \"struct\") {\n            let name_no_prefix = name.replace(\"u_\", \"\");\n            name_no_prefix =\n              name_no_prefix.charAt(0).toUpperCase() + name_no_prefix.slice(1);\n            return (\n              `uniform struct ${name_no_prefix} \\n{\\n` +\n              Object.entries(uniform.value)\n                .map(([name, uniform]: [string, any]) =>\n                  uniform.getDeclaration(name, type).replace(/^uniform/, \"\")\n                )\n                .join(\"\") +\n              `\\n} ${name}${length && length > 0 ? `[${length}]` : \"\"};`\n            );\n          }\n          return `uniform ${uniform.type} ${name}${length && length > 0 ? `[${length}]` : \"\"};`;\n        }\n        return \"\";\n      }\n    };\n\n    // Define PlaneGeometry class\n    _miniGl.PlaneGeometry = class {\n      width: number = 1;\n      height: number = 1;\n      orientation: string = \"xz\";\n      attributes: any;\n      vertexCount: number = 0;\n      quadCount: number = 0;\n      xSegCount: number = 0;\n      ySegCount: number = 0;\n\n      constructor(\n        width?: number,\n        height?: number,\n        n?: number,\n        i?: number,\n        orientation?: string\n      ) {\n        context.createBuffer();\n        this.attributes = {\n          position: new _miniGl.Attribute({\n            target: context.ARRAY_BUFFER,\n            size: 3,\n          }),\n          uv: new _miniGl.Attribute({\n            target: context.ARRAY_BUFFER,\n            size: 2,\n          }),\n          uvNorm: new _miniGl.Attribute({\n            target: context.ARRAY_BUFFER,\n            size: 2,\n          }),\n          index: new _miniGl.Attribute({\n            target: context.ELEMENT_ARRAY_BUFFER,\n            size: 3,\n            type: context.UNSIGNED_SHORT,\n          }),\n        };\n        this.setTopology(n, i);\n        this.setSize(width, height, orientation);\n      }\n\n      setTopology(e = 1, t = 1): void {\n        const n = this;\n        n.xSegCount = e;\n        n.ySegCount = t;\n        n.vertexCount = (n.xSegCount + 1) * (n.ySegCount + 1);\n        n.quadCount = n.xSegCount * n.ySegCount * 2;\n        n.attributes.uv.values = new Float32Array(2 * n.vertexCount);\n        n.attributes.uvNorm.values = new Float32Array(2 * n.vertexCount);\n        n.attributes.index.values = new Uint16Array(3 * n.quadCount);\n\n        for (let e = 0; e <= n.ySegCount; e++) {\n          for (let t = 0; t <= n.xSegCount; t++) {\n            const i = e * (n.xSegCount + 1) + t;\n            n.attributes.uv.values[2 * i] = t / n.xSegCount;\n            n.attributes.uv.values[2 * i + 1] = 1 - e / n.ySegCount;\n            n.attributes.uvNorm.values[2 * i] = (t / n.xSegCount) * 2 - 1;\n            n.attributes.uvNorm.values[2 * i + 1] = 1 - (e / n.ySegCount) * 2;\n\n            if (t < n.xSegCount && e < n.ySegCount) {\n              const s = e * n.xSegCount + t;\n              n.attributes.index.values[6 * s] = i;\n              n.attributes.index.values[6 * s + 1] = i + 1 + n.xSegCount;\n              n.attributes.index.values[6 * s + 2] = i + 1;\n              n.attributes.index.values[6 * s + 3] = i + 1;\n              n.attributes.index.values[6 * s + 4] = i + 1 + n.xSegCount;\n              n.attributes.index.values[6 * s + 5] = i + 2 + n.xSegCount;\n            }\n          }\n        }\n\n        n.attributes.uv.update();\n        n.attributes.uvNorm.update();\n        n.attributes.index.update();\n        _miniGl.debug(\"Geometry.setTopology\", {\n          uv: n.attributes.uv,\n          uvNorm: n.attributes.uvNorm,\n          index: n.attributes.index,\n        });\n      }\n\n      setSize(width = 1, height = 1, orientation = \"xz\"): void {\n        const geometry = this;\n        geometry.width = width;\n        geometry.height = height;\n        geometry.orientation = orientation;\n\n        if (\n          !geometry.attributes.position.values ||\n          geometry.attributes.position.values.length !==\n            3 * geometry.vertexCount\n        ) {\n          geometry.attributes.position.values = new Float32Array(\n            3 * geometry.vertexCount\n          );\n        }\n\n        const o = width / -2;\n        const r = height / -2;\n        const segment_width = width / geometry.xSegCount;\n        const segment_height = height / geometry.ySegCount;\n\n        for (let yIndex = 0; yIndex <= geometry.ySegCount; yIndex++) {\n          const t = r + yIndex * segment_height;\n          for (let xIndex = 0; xIndex <= geometry.xSegCount; xIndex++) {\n            const r = o + xIndex * segment_width;\n            const l = yIndex * (geometry.xSegCount + 1) + xIndex;\n            geometry.attributes.position.values[\n              3 * l + \"xyz\".indexOf(orientation[0]!)\n            ] = r;\n            geometry.attributes.position.values[\n              3 * l + \"xyz\".indexOf(orientation[1]!)\n            ] = -t;\n          }\n        }\n\n        geometry.attributes.position.update();\n        _miniGl.debug(\"Geometry.setSize\", {\n          position: geometry.attributes.position,\n        });\n      }\n    };\n\n    // Define Mesh class\n    _miniGl.Mesh = class {\n      geometry: any;\n      material: any;\n      wireframe: boolean = false;\n      attributeInstances: any[] = [];\n\n      constructor(geometry: any, material: any) {\n        const mesh = this;\n        mesh.geometry = geometry;\n        mesh.material = material;\n\n        Object.entries(mesh.geometry.attributes).forEach(\n          ([e, attribute]: [string, any]) => {\n            mesh.attributeInstances.push({\n              attribute: attribute,\n              location: attribute.attach(e, mesh.material.program),\n            });\n          }\n        );\n\n        _miniGl.meshes.push(mesh);\n        _miniGl.debug(\"Mesh.constructor\", { mesh });\n      }\n\n      draw(): void {\n        context.useProgram(this.material.program);\n        this.material.uniformInstances.forEach(({ uniform, location }: any) =>\n          uniform.update(location)\n        );\n        this.attributeInstances.forEach(({ attribute, location }: any) =>\n          attribute.use(location)\n        );\n        context.drawElements(\n          this.wireframe ? context.LINES : context.TRIANGLES,\n          this.geometry.attributes.index.values.length,\n          context.UNSIGNED_SHORT,\n          0\n        );\n      }\n\n      remove(): void {\n        _miniGl.meshes = _miniGl.meshes.filter((e) => e !== this);\n      }\n    };\n\n    // Define Attribute class\n    _miniGl.Attribute = class {\n      type: number;\n      normalized: boolean = false;\n      buffer: WebGLBuffer;\n      target!: number;\n      size!: number;\n      values?: Float32Array | Uint16Array;\n\n      constructor(e: any) {\n        this.type = context.FLOAT;\n        this.buffer = context.createBuffer()!;\n        Object.assign(this, e);\n        this.update();\n      }\n\n      update(): void {\n        if (this.values !== undefined) {\n          context.bindBuffer(this.target, this.buffer);\n          context.bufferData(this.target, this.values, context.STATIC_DRAW);\n        }\n      }\n\n      attach(e: string, t: WebGLProgram): number {\n        const n = context.getAttribLocation(t, e);\n        if (this.target === context.ARRAY_BUFFER) {\n          context.enableVertexAttribArray(n);\n          context.vertexAttribPointer(\n            n,\n            this.size,\n            this.type,\n            this.normalized,\n            0,\n            0\n          );\n        }\n        return n;\n      }\n\n      use(e: number): void {\n        context.bindBuffer(this.target, this.buffer);\n        if (this.target === context.ARRAY_BUFFER) {\n          context.enableVertexAttribArray(e);\n          context.vertexAttribPointer(\n            e,\n            this.size,\n            this.type,\n            this.normalized,\n            0,\n            0\n          );\n        }\n      }\n    };\n\n    const a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    _miniGl.commonUniforms = {\n      projectionMatrix: new _miniGl.Uniform({ type: \"mat4\", value: a }),\n      modelViewMatrix: new _miniGl.Uniform({ type: \"mat4\", value: a }),\n      resolution: new _miniGl.Uniform({ type: \"vec2\", value: [1, 1] }),\n      aspectRatio: new _miniGl.Uniform({ type: \"float\", value: 1 }),\n    };\n  }\n\n  setSize(e = 640, t = 480): void {\n    this.width = e;\n    this.height = t;\n    this.canvas.width = e;\n    this.canvas.height = t;\n    this.gl.viewport(0, 0, e, t);\n    this.commonUniforms.resolution.value = [e, t];\n    this.commonUniforms.aspectRatio.value = e / t;\n    this.debug(\"MiniGL.setSize\", { width: e, height: t });\n  }\n\n  setOrthographicCamera(e = 0, t = 0, n = 0, i = -2000, s = 2000): void {\n    this.commonUniforms.projectionMatrix.value = [\n      2 / this.width!,\n      0,\n      0,\n      0,\n      0,\n      2 / this.height!,\n      0,\n      0,\n      0,\n      0,\n      2 / (i - s),\n      0,\n      e,\n      t,\n      n,\n      1,\n    ];\n    this.debug(\n      \"setOrthographicCamera\",\n      this.commonUniforms.projectionMatrix.value\n    );\n  }\n\n  render(): void {\n    this.gl.clearColor(0, 0, 0, 0);\n    this.gl.clearDepth(1);\n    this.meshes.forEach((e) => e.draw());\n  }\n}\n\n// Gradient class\nclass Gradient {\n  el!: HTMLCanvasElement;\n  gradientColors!: string[];\n  cssVarRetries = 0;\n  maxCssVarRetries = 200;\n  angle = 0;\n  isLoadedClass = false;\n  isScrolling = false;\n  isStatic = false;\n  scrollingTimeout?: number;\n  scrollingRefreshDelay = 200;\n  isIntersecting = false;\n  shaderFiles?: any;\n  vertexShader?: string;\n  sectionColors?: number[][];\n  conf?: any;\n  uniforms?: any;\n  t = 1253106;\n  last = 0;\n  width?: number;\n  minWidth = 1111;\n  height?: number;\n  minHeight = 1111;\n  xSegCount?: number;\n  ySegCount?: number;\n  mesh?: any;\n  material?: any;\n  geometry?: any;\n  minigl?: MiniGl;\n  scrollObserver?: any;\n  amp = 320;\n  seed = 5;\n  freqX = 0.00014;\n  freqY = 0.00029;\n  freqDelta = 0.00001;\n  activeColors = [1, 1, 1, 1];\n  isMetaKey = false;\n  isGradientLegendVisible = false;\n  isMouseDown = false;\n\n  constructor() {}\n\n  handleScroll = (): void => {\n    clearTimeout(this.scrollingTimeout);\n    this.scrollingTimeout = window.setTimeout(\n      this.handleScrollEnd,\n      this.scrollingRefreshDelay\n    );\n    if (this.isGradientLegendVisible) this.hideGradientLegend();\n    if (this.conf.playing) {\n      this.isScrolling = true;\n      this.pause();\n    }\n  };\n\n  handleScrollEnd = (): void => {\n    this.isScrolling = false;\n    if (this.isIntersecting) this.play();\n  };\n\n  resize = (): void => {\n    this.width = window.innerWidth;\n    this.height = window.innerHeight;\n    this.minigl!.setSize(this.width, this.height);\n    this.minigl!.setOrthographicCamera();\n    this.xSegCount = Math.ceil(this.width * this.conf.density[0]);\n    this.ySegCount = Math.ceil(this.height * this.conf.density[1]);\n    this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount);\n    this.mesh.geometry.setSize(this.width, this.height);\n    this.mesh.material.uniforms.u_shadow_power.value = this.width < 600 ? 5 : 6;\n  };\n\n  animate = (e: number): void => {\n    if (!this.shouldSkipFrame(e) || this.isMouseDown) {\n      if (this.t !== undefined && this.last !== undefined) {\n        this.t += Math.min(e - this.last, 1000 / 15);\n        this.last = e;\n\n        if (this.isMouseDown) {\n          let delta = 160;\n          if (this.isMetaKey) delta = -160;\n          this.t += delta;\n        }\n\n        this.mesh.material.uniforms.u_time.value = this.t;\n        this.minigl!.render();\n      }\n    }\n\n    if (this.last !== 0 && this.isStatic) {\n      this.minigl!.render();\n      this.disconnect();\n      return;\n    }\n\n    if (this.conf.playing || this.isMouseDown) {\n      requestAnimationFrame(this.animate);\n    }\n  };\n\n  addIsLoadedClass = (): void => {\n    if (!this.isLoadedClass) {\n      this.isLoadedClass = true;\n      this.el.classList.add(\"isLoaded\");\n    }\n  };\n\n  pause = (): void => {\n    this.conf.playing = false;\n  };\n\n  play = (): void => {\n    requestAnimationFrame(this.animate);\n    this.conf.playing = true;\n  };\n\n  initGradient = (options?: {\n    el?: HTMLCanvasElement;\n    gradientColors?: string[];\n  }): Gradient => {\n    const { el, gradientColors = [] } = options || {};\n    this.el = el || document.createElement(\"canvas\");\n    this.gradientColors = gradientColors;\n    this.connect();\n    return this;\n  };\n\n  async connect(): Promise<void> {\n    this.shaderFiles = {\n      vertex: `varying vec3 v_color;\n\nvoid main() {\n  float time = u_time * u_global.noiseSpeed;\n\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\n\n  vec2 st = 1. - uvNorm.xy;\n\n  //\n  // Tilting the plane\n  //\n\n  // Front-to-back tilt\n  float tilt = resolution.y / 2.0 * uvNorm.y;\n\n  // Left-to-right angle\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\n\n  // Up-down shift to offset incline\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\n\n  //\n  // Vertex noise\n  //\n\n  float noise = snoise(vec3(\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\n  )) * u_vertDeform.noiseAmp;\n\n  // Fade noise to zero at edges\n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\n\n  // Clamp to 0\n  noise = max(0.0, noise);\n\n  vec3 pos = vec3(\n    position.x,\n    position.y + tilt + incline + noise - offset,\n    position.z\n  );\n\n  //\n  // Vertex color, to be passed to fragment shader\n  //\n\n  if (u_active_colors[0] == 1.) {\n    v_color = u_baseColor;\n  }\n\n  for (int i = 0; i < u_waveLayers_length; i++) {\n    if (u_active_colors[i + 1] == 1.) {\n      WaveLayers layer = u_waveLayers[i];\n\n      float noise = smoothstep(\n        layer.noiseFloor,\n        layer.noiseCeil,\n        snoise(vec3(\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\n          noiseCoord.y * layer.noiseFreq.y,\n          time * layer.noiseSpeed + layer.noiseSeed\n        )) / 2.0 + 0.5\n      );\n\n      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));\n    }\n  }\n\n  //\n  // Finish\n  //\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}`,\n      noise: ` \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //  vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}`,\n      blend: ` \n\nvec3 blendNormal(vec3 base, vec3 blend) {\n\\treturn blend;\n}\n\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Screen\n\nfloat blendScreen(float base, float blend) {\n\\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Multiply\n\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Overlay\n\nfloat blendOverlay(float base, float blend) {\n\\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Hard light\n\nvec3 blendHardLight(vec3 base, vec3 blend) {\n\\treturn blendOverlay(blend,base);\n}\n\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Soft light\n\nfloat blendSoftLight(float base, float blend) {\n\\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Color dodge\n\nfloat blendColorDodge(float base, float blend) {\n\\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Color burn\n\nfloat blendColorBurn(float base, float blend) {\n\\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend) {\n\\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Vivid Light\n\nfloat blendVividLight(float base, float blend) {\n\\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend) {\n\\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Lighten\n\nfloat blendLighten(float base, float blend) {\n\\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Linear burn\n\nfloat blendLinearBurn(float base, float blend) {\n\\t// Note : Same implementation as BlendSubtractf\n\\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\\t// Note : Same implementation as BlendSubtract\n\\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Linear dodge\n\nfloat blendLinearDodge(float base, float blend) {\n\\t// Note : Same implementation as BlendAddf\n\\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\\t// Note : Same implementation as BlendAdd\n\\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// Linear light\n\nfloat blendLinearLight(float base, float blend) {\n\\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}`,\n      fragment: `varying vec3 v_color;\n\nvoid main() {\n  vec3 color = v_color;\n  if (u_darken_top == 1.0) {\n    vec2 st = gl_FragCoord.xy/resolution.xy;\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\n  }\n  gl_FragColor = vec4(color, 1.0);\n}`,\n    };\n\n    this.conf = {\n      presetName: \"\",\n      wireframe: false,\n      density: [0.02, 0.05],\n      zoom: 1,\n      rotation: 0,\n      playing: true,\n    };\n\n    this.minigl = new MiniGl(this.el, null, null, true);\n    this.init();\n    this.addIsLoadedClass();\n  }\n\n  disconnect(): void {\n    if (this.scrollObserver) {\n      window.removeEventListener(\"scroll\", this.handleScroll);\n      window.removeEventListener(\"mousedown\", this.handleMouseDown);\n      window.removeEventListener(\"mouseup\", this.handleMouseUp);\n      this.scrollObserver.disconnect();\n    }\n    window.removeEventListener(\"resize\", this.resize);\n  }\n\n  handleMouseDown = (): void => {};\n  handleMouseUp = (): void => {};\n\n  initMaterial(): any {\n    this.uniforms = {\n      u_time: new this.minigl!.Uniform({ value: 0 }),\n      u_shadow_power: new this.minigl!.Uniform({ value: 5 }),\n      u_darken_top: new this.minigl!.Uniform({\n        value: this.el.dataset.jsDarkenTop === \"\" ? 1 : 0,\n      }),\n      u_active_colors: new this.minigl!.Uniform({\n        value: this.activeColors,\n        type: \"vec4\",\n      }),\n      u_global: new this.minigl!.Uniform({\n        value: {\n          noiseFreq: new this.minigl!.Uniform({\n            value: [this.freqX, this.freqY],\n            type: \"vec2\",\n          }),\n          noiseSpeed: new this.minigl!.Uniform({ value: 0.000005 }),\n        },\n        type: \"struct\",\n      }),\n      u_vertDeform: new this.minigl!.Uniform({\n        value: {\n          incline: new this.minigl!.Uniform({\n            value: Math.sin(this.angle) / Math.cos(this.angle),\n          }),\n          offsetTop: new this.minigl!.Uniform({ value: -0.5 }),\n          offsetBottom: new this.minigl!.Uniform({ value: -0.5 }),\n          noiseFreq: new this.minigl!.Uniform({\n            value: [3, 4],\n            type: \"vec2\",\n          }),\n          noiseAmp: new this.minigl!.Uniform({ value: this.amp }),\n          noiseSpeed: new this.minigl!.Uniform({ value: 10 }),\n          noiseFlow: new this.minigl!.Uniform({ value: 3 }),\n          noiseSeed: new this.minigl!.Uniform({ value: this.seed }),\n        },\n        type: \"struct\",\n        excludeFrom: \"fragment\",\n      }),\n      u_baseColor: new this.minigl!.Uniform({\n        value: this.sectionColors![0],\n        type: \"vec3\",\n        excludeFrom: \"fragment\",\n      }),\n      u_waveLayers: new this.minigl!.Uniform({\n        value: [],\n        excludeFrom: \"fragment\",\n        type: \"array\",\n      }),\n    };\n\n    for (let e = 1; e < this.sectionColors!.length; e += 1) {\n      this.uniforms.u_waveLayers.value.push(\n        new this.minigl!.Uniform({\n          value: {\n            color: new this.minigl!.Uniform({\n              value: this.sectionColors![e],\n              type: \"vec3\",\n            }),\n            noiseFreq: new this.minigl!.Uniform({\n              value: [\n                2 + e / this.sectionColors!.length,\n                3 + e / this.sectionColors!.length,\n              ],\n              type: \"vec2\",\n            }),\n            noiseSpeed: new this.minigl!.Uniform({ value: 11 + 0.3 * e }),\n            noiseFlow: new this.minigl!.Uniform({ value: 6.5 + 0.3 * e }),\n            noiseSeed: new this.minigl!.Uniform({ value: this.seed + 10 * e }),\n            noiseFloor: new this.minigl!.Uniform({ value: 0.1 }),\n            noiseCeil: new this.minigl!.Uniform({ value: 0.63 + 0.07 * e }),\n          },\n          type: \"struct\",\n        })\n      );\n    }\n\n    this.vertexShader = [\n      this.shaderFiles!.noise,\n      this.shaderFiles!.blend,\n      this.shaderFiles!.vertex,\n    ].join(\"\\n\\n\");\n\n    return new this.minigl!.Material(\n      this.vertexShader,\n      this.shaderFiles!.fragment,\n      this.uniforms\n    );\n  }\n\n  initMesh(): void {\n    this.material = this.initMaterial();\n    this.geometry = new this.minigl!.PlaneGeometry();\n    this.mesh = new this.minigl!.Mesh(this.geometry, this.material);\n  }\n\n  shouldSkipFrame(e: number): boolean {\n    return (\n      !!window.document.hidden ||\n      !this.conf.playing ||\n      parseInt(e.toString(), 10) % 2 === 0\n    );\n  }\n\n  updateFrequency(e: number): void {\n    this.freqX += e;\n    this.freqY += e;\n  }\n\n  toggleColor(index: number): void {\n    this.activeColors[index] = this.activeColors[index] === 0 ? 1 : 0;\n  }\n\n  showGradientLegend(): void {\n    if (this.width! > this.minWidth) {\n      this.isGradientLegendVisible = true;\n      document.body.classList.add(\"isGradientLegendVisible\");\n    }\n  }\n\n  hideGradientLegend(): void {\n    this.isGradientLegendVisible = false;\n    document.body.classList.remove(\"isGradientLegendVisible\");\n  }\n\n  init(): void {\n    this.initGradientColors();\n    this.initMesh();\n    this.resize();\n    requestAnimationFrame(this.animate);\n    window.addEventListener(\"resize\", this.resize);\n  }\n\n  initGradientColors(): void {\n    this.sectionColors = (this.gradientColors || [\"#ef008f\", \"#6ec3f4\"]).map(\n      (hex) => normalizeColor(parseInt(hex.replace(\"#\", \"0x\"), 16))\n    );\n  }\n}\n\ninterface GradientWaveProps {\n  gradientColors?: string[];\n  width?: string | number;\n  height?: string | number;\n  amp?: number;\n  freqX?: number;\n  freqY?: number;\n  speed?: number;\n  rotation?: number;\n  darkenTop?: boolean;\n  density?: [number, number];\n  onInit?: (gradient: Gradient) => void;\n}\n\nexport function GradientWave({\n  gradientColors = [\"#ef008f\", \"#6ec3f4\", \"#7038ff\", \"#ffba27\"],\n  width = \"100%\",\n  height = \"100%\",\n  amp = 200,\n  freqX = 0.0001,\n  freqY = 0.0002,\n  speed = 1,\n  rotation = 0,\n  darkenTop = true,\n  density = [0.5, 0.5],\n  onInit,\n}: GradientWaveProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const gradientRef = useRef<Gradient | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const gradient = new Gradient();\n\n    // Override defaults\n    gradient.amp = amp;\n    gradient.freqX = freqX;\n    gradient.freqY = freqY;\n    gradient.angle = rotation;\n    gradient.conf = { ...gradient.conf, density };\n\n    const canvas =\n      containerRef.current.querySelector(\"canvas\") ??\n      document.createElement(\"canvas\");\n    if (darkenTop) canvas.dataset.jsDarkenTop = \"\";\n\n    gradient.initGradient({ el: canvas, gradientColors });\n    containerRef.current.appendChild(canvas);\n    gradientRef.current = gradient;\n\n    if (onInit) onInit(gradient);\n\n    return () => {\n      gradient.disconnect();\n      if (containerRef.current?.contains(canvas))\n        containerRef.current.removeChild(canvas);\n      gradient.minigl?.gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    };\n  }, [\n    gradientColors,\n    amp,\n    freqX,\n    freqY,\n    speed,\n    rotation,\n    darkenTop,\n    density,\n    onInit,\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      style={{ width, height, position: \"absolute\", overflow: \"hidden\" }}\n    />\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}