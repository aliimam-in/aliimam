{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "gradient-wave",
  "type": "registry:component",
  "files": [
    {
      "path": "registry/default/components/gradient-wave.tsx",
      "content": "\"use client\";\nimport { useEffect, useRef } from \"react\";\n\nfunction normalizeColor(hexCode: number): number[] {\n  return [\n    ((hexCode >> 16) & 255) / 255,\n    ((hexCode >> 8) & 255) / 255,\n    (255 & hexCode) / 255,\n  ];\n}\n\nclass MiniGl {\n  canvas: HTMLCanvasElement;\n  gl: WebGLRenderingContext;\n  meshes: any[] = [];\n  commonUniforms: any;\n  width?: number;\n  height?: number;\n  Material: any;\n  Uniform: any;\n  PlaneGeometry: any;\n  Mesh: any;\n  Attribute: any;\n\n  constructor(canvas: HTMLCanvasElement) {\n    this.canvas = canvas;\n    const gl = this.canvas.getContext(\"webgl\", { antialias: true });\n    if (!gl) throw new Error(\"WebGL not supported\");\n    this.gl = gl;\n\n    const context = this.gl;\n    const _miniGl = this;\n\n    this.Uniform = class {\n      type: string = \"float\";\n      value: any;\n      typeFn: string;\n      excludeFrom?: string;\n      transpose?: boolean;\n\n      constructor(e: any) {\n        Object.assign(this, e);\n        const typeMap: Record<string, string> = {\n          float: \"1f\",\n          int: \"1i\",\n          vec2: \"2fv\",\n          vec3: \"3fv\",\n          vec4: \"4fv\",\n          mat4: \"Matrix4fv\",\n        };\n        this.typeFn = typeMap[this.type] || \"1f\";\n      }\n\n      update(location: any): void {\n        if (this.value === undefined || location === null) return;\n\n        const isMatrix = this.typeFn.indexOf(\"Matrix\") === 0;\n        const fn = `uniform${this.typeFn}`;\n\n        if (isMatrix) {\n          (context as any)[fn](location, this.transpose || false, this.value);\n        } else {\n          (context as any)[fn](location, this.value);\n        }\n      }\n\n      getDeclaration(name: string, type: string, length?: number): string {\n        if (this.excludeFrom === type) return \"\";\n\n        if (this.type === \"array\") {\n          return (\n            this.value[0].getDeclaration(name, type, this.value.length) +\n            `\\nconst int ${name}_length = ${this.value.length};`\n          );\n        }\n\n        if (this.type === \"struct\") {\n          let nameNoPrefix = name.replace(\"u_\", \"\");\n          nameNoPrefix =\n            nameNoPrefix.charAt(0).toUpperCase() + nameNoPrefix.slice(1);\n          const fields = Object.entries(this.value)\n            .map(([n, u]: [string, any]) =>\n              u.getDeclaration(n, type).replace(/^uniform/, \"\")\n            )\n            .join(\"\");\n          return `uniform struct ${nameNoPrefix} \\n{\\n${fields}\\n} ${name}${length ? `[${length}]` : \"\"};`;\n        }\n\n        return `uniform ${this.type} ${name}${length ? `[${length}]` : \"\"};`;\n      }\n    };\n\n    this.Attribute = class {\n      type: number = context.FLOAT;\n      normalized: boolean = false;\n      buffer: WebGLBuffer;\n      target!: number;\n      size!: number;\n      values?: Float32Array | Uint16Array;\n\n      constructor(e: any) {\n        this.buffer = context.createBuffer()!;\n        Object.assign(this, e);\n      }\n\n      update(): void {\n        if (this.values) {\n          context.bindBuffer(this.target, this.buffer);\n          context.bufferData(this.target, this.values, context.STATIC_DRAW);\n        }\n      }\n\n      attach(e: string, t: WebGLProgram): number {\n        const n = context.getAttribLocation(t, e);\n        if (this.target === context.ARRAY_BUFFER) {\n          context.bindBuffer(this.target, this.buffer);\n          context.enableVertexAttribArray(n);\n          context.vertexAttribPointer(\n            n,\n            this.size,\n            this.type,\n            this.normalized,\n            0,\n            0\n          );\n        }\n        return n;\n      }\n\n      use(e: number): void {\n        context.bindBuffer(this.target, this.buffer);\n        if (this.target === context.ARRAY_BUFFER) {\n          context.enableVertexAttribArray(e);\n          context.vertexAttribPointer(\n            e,\n            this.size,\n            this.type,\n            this.normalized,\n            0,\n            0\n          );\n        }\n      }\n    };\n\n    this.Material = class {\n      uniforms: any;\n      uniformInstances: any[] = [];\n      program!: WebGLProgram;\n\n      constructor(\n        vertexShaders: string,\n        fragments: string,\n        uniforms: any = {}\n      ) {\n        const material = this;\n\n        function getShader(type: number, source: string): WebGLShader {\n          const shader = context.createShader(type)!;\n          context.shaderSource(shader, source);\n          context.compileShader(shader);\n          if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {\n            console.error(context.getShaderInfoLog(shader));\n            throw new Error(\"Shader compilation error\");\n          }\n          return shader;\n        }\n\n        function getUniformDeclarations(uniforms: any, type: string): string {\n          return Object.entries(uniforms)\n            .map(([uniform, value]: [string, any]) =>\n              value.getDeclaration(uniform, type)\n            )\n            .join(\"\\n\");\n        }\n\n        material.uniforms = uniforms;\n        const prefix = \"precision highp float;\";\n\n        const vertexSource = `\n          ${prefix}\n          attribute vec4 position;\n          attribute vec2 uv;\n          attribute vec2 uvNorm;\n          ${getUniformDeclarations(_miniGl.commonUniforms, \"vertex\")}\n          ${getUniformDeclarations(uniforms, \"vertex\")}\n          ${vertexShaders}\n        `;\n\n        const fragmentSource = `\n          ${prefix}\n          ${getUniformDeclarations(_miniGl.commonUniforms, \"fragment\")}\n          ${getUniformDeclarations(uniforms, \"fragment\")}\n          ${fragments}\n        `;\n\n        material.program = context.createProgram()!;\n        context.attachShader(\n          material.program,\n          getShader(context.VERTEX_SHADER, vertexSource)\n        );\n        context.attachShader(\n          material.program,\n          getShader(context.FRAGMENT_SHADER, fragmentSource)\n        );\n        context.linkProgram(material.program);\n\n        if (\n          !context.getProgramParameter(material.program, context.LINK_STATUS)\n        ) {\n          console.error(context.getProgramInfoLog(material.program));\n          throw new Error(\"Program linking error\");\n        }\n\n        context.useProgram(material.program);\n        material.attachUniforms(undefined, _miniGl.commonUniforms);\n        material.attachUniforms(undefined, material.uniforms);\n      }\n\n      attachUniforms(name: string | undefined, uniforms: any): void {\n        if (name === undefined) {\n          Object.entries(uniforms).forEach(([n, u]) =>\n            this.attachUniforms(n, u)\n          );\n        } else if (uniforms.type === \"array\") {\n          uniforms.value.forEach((u: any, i: number) =>\n            this.attachUniforms(`${name}[${i}]`, u)\n          );\n        } else if (uniforms.type === \"struct\") {\n          Object.entries(uniforms.value).forEach(([u, i]) =>\n            this.attachUniforms(`${name}.${u}`, i)\n          );\n        } else {\n          this.uniformInstances.push({\n            uniform: uniforms,\n            location: context.getUniformLocation(this.program, name),\n          });\n        }\n      }\n    };\n\n    this.PlaneGeometry = class {\n      width: number = 1;\n      height: number = 1;\n      attributes: any;\n      vertexCount: number = 0;\n      xSegCount: number = 0;\n      ySegCount: number = 0;\n\n      constructor() {\n        this.attributes = {\n          position: new _miniGl.Attribute({\n            target: context.ARRAY_BUFFER,\n            size: 3,\n          }),\n          uv: new _miniGl.Attribute({ target: context.ARRAY_BUFFER, size: 2 }),\n          uvNorm: new _miniGl.Attribute({\n            target: context.ARRAY_BUFFER,\n            size: 2,\n          }),\n          index: new _miniGl.Attribute({\n            target: context.ELEMENT_ARRAY_BUFFER,\n            size: 3,\n            type: context.UNSIGNED_SHORT,\n          }),\n        };\n      }\n\n      setTopology(xSegs = 1, ySegs = 1): void {\n        this.xSegCount = xSegs;\n        this.ySegCount = ySegs;\n        this.vertexCount = (this.xSegCount + 1) * (this.ySegCount + 1);\n        const quadCount = this.xSegCount * this.ySegCount * 2;\n\n        this.attributes.uv.values = new Float32Array(2 * this.vertexCount);\n        this.attributes.uvNorm.values = new Float32Array(2 * this.vertexCount);\n        this.attributes.index.values = new Uint16Array(3 * quadCount);\n\n        for (let y = 0; y <= this.ySegCount; y++) {\n          for (let x = 0; x <= this.xSegCount; x++) {\n            const i = y * (this.xSegCount + 1) + x;\n            this.attributes.uv.values[2 * i] = x / this.xSegCount;\n            this.attributes.uv.values[2 * i + 1] = 1 - y / this.ySegCount;\n            this.attributes.uvNorm.values[2 * i] = (x / this.xSegCount) * 2 - 1;\n            this.attributes.uvNorm.values[2 * i + 1] =\n              1 - (y / this.ySegCount) * 2;\n\n            if (x < this.xSegCount && y < this.ySegCount) {\n              const s = y * this.xSegCount + x;\n              this.attributes.index.values[6 * s] = i;\n              this.attributes.index.values[6 * s + 1] = i + 1 + this.xSegCount;\n              this.attributes.index.values[6 * s + 2] = i + 1;\n              this.attributes.index.values[6 * s + 3] = i + 1;\n              this.attributes.index.values[6 * s + 4] = i + 1 + this.xSegCount;\n              this.attributes.index.values[6 * s + 5] = i + 2 + this.xSegCount;\n            }\n          }\n        }\n\n        this.attributes.uv.update();\n        this.attributes.uvNorm.update();\n        this.attributes.index.update();\n      }\n\n      setSize(width = 1, height = 1): void {\n        this.width = width;\n        this.height = height;\n        this.attributes.position.values = new Float32Array(\n          3 * this.vertexCount\n        );\n\n        const offsetX = width / -2;\n        const offsetY = height / -2;\n        const segWidth = width / this.xSegCount;\n        const segHeight = height / this.ySegCount;\n\n        for (let y = 0; y <= this.ySegCount; y++) {\n          const posY = offsetY + y * segHeight;\n          for (let x = 0; x <= this.xSegCount; x++) {\n            const posX = offsetX + x * segWidth;\n            const idx = y * (this.xSegCount + 1) + x;\n            this.attributes.position.values[3 * idx] = posX;\n            this.attributes.position.values[3 * idx + 1] = -posY;\n            this.attributes.position.values[3 * idx + 2] = 0;\n          }\n        }\n\n        this.attributes.position.update();\n      }\n    };\n\n    this.Mesh = class {\n      geometry: any;\n      material: any;\n      attributeInstances: any[] = [];\n\n      constructor(geometry: any, material: any) {\n        this.geometry = geometry;\n        this.material = material;\n\n        Object.entries(this.geometry.attributes).forEach(\n          ([e, attribute]: [string, any]) => {\n            this.attributeInstances.push({\n              attribute: attribute,\n              location: attribute.attach(e, this.material.program),\n            });\n          }\n        );\n\n        _miniGl.meshes.push(this);\n      }\n\n      draw(): void {\n        context.useProgram(this.material.program);\n        this.material.uniformInstances.forEach(({ uniform, location }: any) =>\n          uniform.update(location)\n        );\n        this.attributeInstances.forEach(({ attribute, location }: any) =>\n          attribute.use(location)\n        );\n        context.drawElements(\n          context.TRIANGLES,\n          this.geometry.attributes.index.values.length,\n          context.UNSIGNED_SHORT,\n          0\n        );\n      }\n    };\n\n    const identityMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    this.commonUniforms = {\n      projectionMatrix: new this.Uniform({\n        type: \"mat4\",\n        value: identityMatrix,\n      }),\n      modelViewMatrix: new this.Uniform({\n        type: \"mat4\",\n        value: identityMatrix,\n      }),\n      resolution: new this.Uniform({ type: \"vec2\", value: [1, 1] }),\n      aspectRatio: new this.Uniform({ type: \"float\", value: 1 }),\n    };\n  }\n\n  setSize(w = 640, h = 480): void {\n    this.width = w;\n    this.height = h;\n    this.canvas.width = w;\n    this.canvas.height = h;\n    this.gl.viewport(0, 0, w, h);\n    this.commonUniforms.resolution.value = [w, h];\n    this.commonUniforms.aspectRatio.value = w / h;\n  }\n\n  setOrthographicCamera(): void {\n    this.commonUniforms.projectionMatrix.value = [\n      2 / this.width!,\n      0,\n      0,\n      0,\n      0,\n      2 / this.height!,\n      0,\n      0,\n      0,\n      0,\n      -0.001,\n      0,\n      0,\n      0,\n      0,\n      1,\n    ];\n  }\n\n  render(): void {\n    this.gl.clearColor(0, 0, 0, 0);\n    this.gl.clearDepth(1);\n    this.meshes.forEach((m) => m.draw());\n  }\n}\n\nclass Gradient {\n  canvas: HTMLCanvasElement;\n  colors: string[];\n  minigl: MiniGl;\n  mesh: any;\n  time = 0;\n  last = 0;\n  animationId?: number;\n  isPlaying = false;\n\n  constructor(canvas: HTMLCanvasElement, colors: string[]) {\n    this.canvas = canvas;\n    this.colors = colors;\n    this.minigl = new MiniGl(canvas);\n    this.init();\n  }\n\n  init(): void {\n    const sectionColors = this.colors.map((hex) =>\n      normalizeColor(parseInt(hex.replace(\"#\", \"0x\"), 16))\n    );\n\n    const uniforms = {\n      u_time: new this.minigl.Uniform({ value: 0 }),\n      u_shadow_power: new this.minigl.Uniform({ value: 5 }),\n      u_darken_top: new this.minigl.Uniform({ value: 0 }),\n      u_active_colors: new this.minigl.Uniform({\n        value: [1, 1, 1, 1],\n        type: \"vec4\",\n      }),\n      u_global: new this.minigl.Uniform({\n        value: {\n          noiseFreq: new this.minigl.Uniform({\n            value: [0.00014, 0.00029],\n            type: \"vec2\",\n          }),\n          noiseSpeed: new this.minigl.Uniform({ value: 0.000005 }),\n        },\n        type: \"struct\",\n      }),\n      u_vertDeform: new this.minigl.Uniform({\n        value: {\n          incline: new this.minigl.Uniform({ value: 0 }),\n          offsetTop: new this.minigl.Uniform({ value: -0.5 }),\n          offsetBottom: new this.minigl.Uniform({ value: -0.5 }),\n          noiseFreq: new this.minigl.Uniform({ value: [3, 4], type: \"vec2\" }),\n          noiseAmp: new this.minigl.Uniform({ value: 320 }),\n          noiseSpeed: new this.minigl.Uniform({ value: 10 }),\n          noiseFlow: new this.minigl.Uniform({ value: 3 }),\n          noiseSeed: new this.minigl.Uniform({ value: 5 }),\n        },\n        type: \"struct\",\n        excludeFrom: \"fragment\",\n      }),\n      u_baseColor: new this.minigl.Uniform({\n        value: sectionColors[0],\n        type: \"vec3\",\n        excludeFrom: \"fragment\",\n      }),\n      u_waveLayers: new this.minigl.Uniform({\n        value: [],\n        excludeFrom: \"fragment\",\n        type: \"array\",\n      }),\n    };\n\n    for (let i = 1; i < sectionColors.length; i++) {\n      uniforms.u_waveLayers.value.push(\n        new this.minigl.Uniform({\n          value: {\n            color: new this.minigl.Uniform({\n              value: sectionColors[i],\n              type: \"vec3\",\n            }),\n            noiseFreq: new this.minigl.Uniform({\n              value: [\n                2 + i / sectionColors.length,\n                3 + i / sectionColors.length,\n              ],\n              type: \"vec2\",\n            }),\n            noiseSpeed: new this.minigl.Uniform({ value: 11 + 0.3 * i }),\n            noiseFlow: new this.minigl.Uniform({ value: 6.5 + 0.3 * i }),\n            noiseSeed: new this.minigl.Uniform({ value: 5 + 10 * i }),\n            noiseFloor: new this.minigl.Uniform({ value: 0.1 }),\n            noiseCeil: new this.minigl.Uniform({ value: 0.63 + 0.07 * i }),\n          },\n          type: \"struct\",\n        })\n      );\n    }\n\n    const vertexShader = `\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n  i = mod289(i);\n  vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n  float n_ = 0.142857142857;\n  vec3 ns = n_ * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nvec3 blendNormal(vec3 base, vec3 blend) { return blend; }\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) { return (blend * opacity + base * (1.0 - opacity)); }\n\nvarying vec3 v_color;\n\nvoid main() {\n  float time = u_time * u_global.noiseSpeed;\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\n  float tilt = resolution.y / 2.0 * uvNorm.y;\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\n  \n  float noise = snoise(vec3(\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\n  )) * u_vertDeform.noiseAmp;\n  \n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\n  noise = max(0.0, noise);\n  \n  vec3 pos = vec3(position.x, position.y + tilt + incline + noise - offset, position.z);\n  \n  v_color = u_baseColor;\n  \n  for (int i = 0; i < u_waveLayers_length; i++) {\n    if (u_active_colors[i + 1] == 1.) {\n      WaveLayers layer = u_waveLayers[i];\n      float layerNoise = smoothstep(\n        layer.noiseFloor,\n        layer.noiseCeil,\n        snoise(vec3(\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\n          noiseCoord.y * layer.noiseFreq.y,\n          time * layer.noiseSpeed + layer.noiseSeed\n        )) / 2.0 + 0.5\n      );\n      v_color = blendNormal(v_color, layer.color, pow(layerNoise, 4.));\n    }\n  }\n  \n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n}`;\n\n    const fragmentShader = `\nvarying vec3 v_color;\n\nvoid main() {\n  vec3 color = v_color;\n  if (u_darken_top == 1.0) {\n    vec2 st = gl_FragCoord.xy/resolution.xy;\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\n  }\n  gl_FragColor = vec4(color, 1.0);\n}`;\n\n    const material = new this.minigl.Material(\n      vertexShader,\n      fragmentShader,\n      uniforms\n    );\n    const geometry = new this.minigl.PlaneGeometry();\n    this.mesh = new this.minigl.Mesh(geometry, material);\n\n    this.resize();\n    window.addEventListener(\"resize\", () => this.resize());\n  }\n\n  resize(): void {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n    this.minigl.setSize(width, height);\n    this.minigl.setOrthographicCamera();\n\n    const xSegCount = Math.ceil(width * 0.02);\n    const ySegCount = Math.ceil(height * 0.05);\n    this.mesh.geometry.setTopology(xSegCount, ySegCount);\n    this.mesh.geometry.setSize(width, height);\n    this.mesh.material.uniforms.u_shadow_power.value = width < 600 ? 5 : 6;\n  }\n\n  animate = (timestamp: number): void => {\n    if (!this.isPlaying) return;\n\n    this.time += Math.min(timestamp - this.last, 1000 / 15);\n    this.last = timestamp;\n    this.mesh.material.uniforms.u_time.value = this.time;\n    this.minigl.render();\n\n    this.animationId = requestAnimationFrame(this.animate);\n  };\n\n  start(): void {\n    this.isPlaying = true;\n    this.animationId = requestAnimationFrame(this.animate);\n  }\n\n  stop(): void {\n    this.isPlaying = false;\n    if (this.animationId) {\n      cancelAnimationFrame(this.animationId);\n    }\n  }\n}\n\ninterface GradientWaveProps {\n  colors?: string[]; // gradient colors\n  isPlaying?: boolean; // animation toggle\n  className?: string; // custom Tailwind classes\n  shadowPower?: number; // strength of top darkening\n  darkenTop?: boolean; // enable/disable top shadow\n  noiseSpeed?: number; // global noise animation speed\n  noiseFrequency?: [number, number]; // global noise frequency\n  deform?: {\n    incline?: number;\n    offsetTop?: number;\n    offsetBottom?: number;\n    noiseFreq?: [number, number];\n    noiseAmp?: number;\n    noiseSpeed?: number;\n    noiseFlow?: number;\n    noiseSeed?: number;\n  };\n}\n\nexport function GradientWave({\n  colors = [\"#38bdf8\", \"#ffffff\", \"#38bdf8\", \"#ffffff\", \"#38bdf8\", \"#ffffff\"],\n  isPlaying = true,\n  className = \"\",\n  shadowPower = 8,\n  darkenTop = false,\n  noiseSpeed = 0.00001,\n  noiseFrequency = [0.0001, 0.0009],\n  deform = { incline: 0.5, noiseAmp: 250, noiseFlow: 5 },\n}: GradientWaveProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const gradientRef = useRef<Gradient | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const canvas = document.createElement(\"canvas\");\n    Object.assign(canvas.style, {\n      position: \"absolute\",\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      display: \"block\",\n    });\n    containerRef.current.appendChild(canvas);\n\n    try {\n      const gradient = new Gradient(canvas, colors);\n      gradientRef.current = gradient;\n\n      // apply props to uniforms\n      gradient.mesh.material.uniforms.u_shadow_power.value = shadowPower;\n      gradient.mesh.material.uniforms.u_darken_top.value = darkenTop ? 1 : 0;\n      gradient.mesh.material.uniforms.u_global.value.noiseFreq.value =\n        noiseFrequency;\n      gradient.mesh.material.uniforms.u_global.value.noiseSpeed.value =\n        noiseSpeed;\n\n      // deform settings (only if provided)\n      Object.assign(gradient.mesh.material.uniforms.u_vertDeform.value, {\n        ...gradient.mesh.material.uniforms.u_vertDeform.value,\n        ...deform,\n      });\n\n      if (isPlaying) gradient.start();\n    } catch (error) {\n      console.error(\"Failed to initialize gradient:\", error);\n    }\n\n    return () => {\n      gradientRef.current?.stop();\n      if (containerRef.current?.contains(canvas)) {\n        containerRef.current.removeChild(canvas);\n      }\n    };\n  }, [\n    colors,\n    isPlaying,\n    shadowPower,\n    darkenTop,\n    noiseSpeed,\n    noiseFrequency,\n    deform,\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`absolute inset-0 z-0 w-full h-full overflow-hidden ${className}`}\n    />\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}