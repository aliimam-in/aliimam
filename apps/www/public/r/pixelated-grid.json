{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pixelated-grid",
  "type": "registry:component",
  "files": [
    {
      "path": "registry/default/components/pixelated-grid.tsx",
      "content": "\"use client\"\n\nimport { useEffect, useRef, useState } from \"react\"\n\ninterface PixelGridProps {\n  bgColor?: string\n  pixelColor?: string\n  numPixelsX?: number\n  numPixelsY?: number\n  pixelSize?: number\n  pixelSpacing?: number\n  pixelDeathFade?: number\n  pixelBornFade?: number\n  pixelMaxLife?: number\n  pixelMinLife?: number\n  pixelMaxOffLife?: number\n  pixelMinOffLife?: number\n  className?: string\n  glow?: boolean\n}\n\ninterface Pixel {\n  xPos: number\n  yPos: number\n  alpha: number\n  maxAlpha: number\n  life: number\n  offLife: number\n  isLit: boolean\n  dying: boolean\n  deathFade: number\n  bornFade: number\n  randomizeSelf: () => void\n}\n\nexport function PixelGrid({\n  bgColor = \"transparent\",\n  pixelColor = \"#0000ff\",\n  numPixelsX = 10,\n  numPixelsY = 10,\n  pixelSize = 3,\n  pixelSpacing = 3,\n  pixelDeathFade = 10,\n  pixelBornFade = 50,\n  pixelMaxLife = 500,\n  pixelMinLife = 250,\n  pixelMaxOffLife = 500,\n  pixelMinOffLife = 200,\n  glow = false,\n  className = \"\",\n}: PixelGridProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const pixelsRef = useRef<Pixel[]>([])\n  const [isAppeared, setIsAppeared] = useState(false)\n\n  useEffect(() => {\n    const canvas = canvasRef.current\n    if (!canvas) return\n\n    const c2d = canvas.getContext(\"2d\", { alpha: true })\n    if (!c2d) return\n\n    const resizeCanvas = () => {\n      canvas.width = window.innerWidth\n      canvas.height = window.innerHeight\n    }\n\n    resizeCanvas()\n    window.addEventListener(\"resize\", resizeCanvas)\n\n    const randomAlpha = () => {\n      const rand = Math.random() * 100\n      if (rand > 90) return 1\n      if (rand > 80) return 0.5\n      return 0.1\n    }\n\n    const randomizePixelAttrs = (x: number, y: number): Pixel => {\n      const alpha = randomAlpha()\n      const lit = alpha !== 0.1\n      return {\n        xPos: x * (pixelSize + pixelSpacing),\n        yPos: y * (pixelSize + pixelSpacing),\n        alpha: 0,\n        maxAlpha: alpha,\n        life: Math.floor(Math.random() * (pixelMaxLife - pixelMinLife + 1)) + pixelMinLife,\n        offLife: Math.floor(Math.random() * (pixelMaxOffLife - pixelMinOffLife + 1)) + pixelMinOffLife,\n        isLit: lit,\n        dying: false,\n        deathFade: pixelDeathFade,\n        bornFade: pixelBornFade,\n        randomizeSelf() {\n          const newAlpha = randomAlpha()\n          this.alpha = 0\n          this.maxAlpha = newAlpha\n          this.life = Math.floor(Math.random() * (pixelMaxLife - pixelMinLife + 1)) + pixelMinLife\n          this.offLife = Math.floor(Math.random() * (pixelMaxOffLife - pixelMinOffLife + 1)) + pixelMinOffLife\n          this.isLit = newAlpha !== 0.1\n          this.dying = false\n          this.deathFade = pixelDeathFade\n          this.bornFade = pixelBornFade\n        },\n      }\n    }\n\n    // Initialize pixels dynamically based on viewport\n    const initPixels = () => {\n      const cols = Math.ceil(window.innerWidth / (pixelSize + pixelSpacing))\n      const rows = Math.ceil(window.innerHeight / (pixelSize + pixelSpacing))\n      pixelsRef.current = []\n      for (let y = 0; y < rows; y++) {\n        for (let x = 0; x < cols; x++) {\n          pixelsRef.current.push(randomizePixelAttrs(x, y))\n        }\n      }\n    }\n\n    initPixels()\n    setIsAppeared(true)\n\n    const drawPixel = (pixel: Pixel) => {\n      pixel.alpha = Math.min(Math.max(pixel.alpha, 0.1), pixel.maxAlpha)\n      c2d.fillStyle = `${pixelColor}${Math.floor(pixel.alpha * 255)\n        .toString(16)\n        .padStart(2, \"0\")}`\n\n      c2d.fillRect(pixel.xPos, pixel.yPos, pixelSize, pixelSize)\n\n      if (pixel.isLit) {\n        if (pixel.bornFade <= 0) {\n          if (pixel.life <= 0) {\n            pixel.dying = true\n            if (pixel.deathFade <= 0) pixel.randomizeSelf()\n            else {\n              pixel.alpha = (pixel.deathFade / pixelDeathFade) * pixel.maxAlpha\n              pixel.deathFade--\n            }\n          } else pixel.life--\n        } else {\n          pixel.alpha = pixel.maxAlpha - pixel.bornFade / pixelBornFade\n          pixel.bornFade--\n        }\n      } else {\n        if (pixel.offLife <= 0) pixel.isLit = true\n        pixel.offLife--\n      }\n    }\n\n    const renderLoop = () => {\n      if (bgColor === \"transparent\") c2d.clearRect(0, 0, canvas.width, canvas.height)\n      else {\n        c2d.fillStyle = bgColor\n        c2d.fillRect(0, 0, canvas.width, canvas.height)\n      }\n\n      if (glow) {\n        c2d.shadowBlur = 8\n        c2d.shadowColor = pixelColor\n      } else {\n        c2d.shadowBlur = 0\n      }\n\n      for (const pixel of pixelsRef.current) drawPixel(pixel)\n      requestAnimationFrame(renderLoop)\n    }\n\n    renderLoop()\n\n    return () => {\n      window.removeEventListener(\"resize\", resizeCanvas)\n    }\n  }, [\n    bgColor,\n    pixelColor,\n    pixelSize,\n    pixelSpacing,\n    pixelDeathFade,\n    pixelBornFade,\n    pixelMaxLife,\n    pixelMinLife,\n    pixelMaxOffLife,\n    pixelMinOffLife,\n    glow,\n  ])\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={`w-screen h-fit ${className}`}\n      style={{ \n        backgroundColor: \"transparent\", \n      }}\n    />\n  )\n}\n",
      "type": "registry:component"
    }
  ]
}