{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "gradient-bars",
  "type": "registry:component",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "registry/default/components/gradient-bars.tsx",
      "content": "\"use client\"\n\nimport { Renderer, Program, Mesh, Color, Triangle } from \"ogl\"\nimport type React from \"react\"\nimport { useEffect, useRef } from \"react\"\n\n// Vertex Shader\nconst vertexShader = `#version 300 es\nprecision highp float;\n\nin vec2 position;\nout vec2 vUv;\n\nvoid main() {\n    vUv = position * 0.5 + 0.5;\n    gl_Position = vec4(position, 0.0, 1.0);\n}`\n\n// Fragment Shader\nconst fragmentShader = `#version 300 es\nprecision highp float;\n\nuniform float uTime;\nuniform vec3 uColor;\n\nin vec2 vUv;\nout vec4 fragColor;\n\n// Color Ramp Macro\nstruct ColorStop {\n    vec3 color;\n    float position;\n};\n\n#define COLOR_RAMP(colors, factor, finalColor) { \\\n    int index = 0; \\\n    for (int i = 0; i < colors.length() - 1; i++) { \\\n        ColorStop currentColor = colors[i]; \\\n        bool isInBetween = currentColor.position <= factor; \\\n        index = int(mix(float(index), float(i), float(isInBetween))); \\\n    } \\\n    ColorStop currentColor = colors[index]; \\\n    ColorStop nextColor = colors[index + 1]; \\\n    float range = nextColor.position - currentColor.position; \\\n    float lerpFactor = (factor - currentColor.position) / range; \\\n    finalColor = mix(currentColor.color, nextColor.color, lerpFactor); \\\n}\n\nvoid main() {\n    // Define color stops for a retro rainbow effect\n    ColorStop colors[3];\n    colors[0] = ColorStop(vec3(80.0 / 255.0, 180.0 / 255.0, 80.0 / 255.0), 0.0);  // Balanced Lime Green\n    colors[1] = ColorStop(vec3(0.0 / 255.0, 180.0 / 255.0, 150.0 / 255.0), 0.5);  // Balanced Turquoise\n    colors[2] = ColorStop(vec3(0.0 / 255.0, 140.0 / 255.0, 180.0 / 255.0), 1.0);  // Balanced Ocean Blue\n\n    vec3 rampColor;\n    COLOR_RAMP(colors, vUv.x, rampColor);\n\n    float height = (vUv.y * 2.0);\n\n    // Moving scanlines, with subtle dimming effect using cosine\n    float scanline = 0.75 + 0.25 * sin((vUv.y * 200.0) + uTime * 3.0);\n\n    // Final color blending with noise, color ramp, and moving scanline effects\n    fragColor.rgb = scanline * rampColor * (height + vec3(0.0));\n    fragColor.a = 1.0;\n}`\n\ninterface GradientBarsProps extends React.HTMLAttributes<HTMLDivElement> {}\n\nexport function GradientBars(props: GradientBarsProps) {\n  const ctnDom = useRef<HTMLDivElement>(null)\n\n  useEffect(() => {\n    if (!ctnDom.current) {\n      return\n    }\n\n    const ctn = ctnDom.current\n    const renderer = new Renderer()\n    const gl = renderer.gl\n    gl.clearColor(1, 1, 1, 1)\n\n    function resize() {\n      const scale = 1\n      renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale)\n    }\n    window.addEventListener(\"resize\", resize, false)\n    resize()\n\n    const geometry = new Triangle(gl)\n\n    const program = new Program(gl, {\n      vertex: vertexShader,\n      fragment: fragmentShader,\n      uniforms: {\n        uTime: { value: 0 },\n        uColor: { value: new Color(0.3, 0.2, 0.5) },\n        uResolution: { value: [gl.canvas.width, gl.canvas.height] },\n      },\n    })\n\n    const mesh = new Mesh(gl, { geometry, program })\n\n    let animateId: number\n\n    animateId = requestAnimationFrame(update)\n\n    function update(t: number) {\n      animateId = requestAnimationFrame(update)\n      program.uniforms.uTime.value = t * 0.001\n      renderer.render({ scene: mesh })\n    }\n\n    ctn.appendChild(gl.canvas)\n\n    return () => {\n      cancelAnimationFrame(animateId)\n      window.removeEventListener(\"resize\", resize)\n      ctn.removeChild(gl.canvas)\n      gl.getExtension(\"WEBGL_lose_context\")?.loseContext()\n    }\n  }, [])\n\n  return (\n    <div\n      ref={ctnDom}\n      style={{\n        width: \"100%\",\n        height: \"100%\",\n      }}\n      {...props}\n    />\n  )\n}\n",
      "type": "registry:component"
    }
  ]
}